# 聊天状态同步优化说明

## 问题描述

在路由切换时，实时聊天菜单的好友列表的在线状态有一定几率会出现离线状态，而不是从离线变为在线状态。

## 问题原因分析

### 1. 前端状态管理时序问题
- 路由切换时会多次触发状态更新和请求，导致竞态条件
- `App.vue` 和 `Chat.vue` 中的状态处理逻辑重复，造成冲突
- 多个定时器和事件监听器缺乏协调

### 2. WebSocket状态请求防抖机制过于严格
- 3秒防抖限制在路由切换场景下过于严格
- 快速路由切换时状态请求被阻止

### 3. 后端状态管理不够健壮
- 在线用户状态只在主动离线时清理
- 异常断开连接时状态清理不及时

### 4. 状态同步机制缺乏统一性
- 缺乏统一的状态同步入口
- 状态更新事件缺乏来源标识

## 优化方案

### 1. 前端 WebSocket API 优化

#### 改进状态请求机制
```javascript
// 支持强制刷新，跳过防抖限制
requestOnlineUserStatus(force = false) {
  // 防抖：3秒内不重复请求，除非强制刷新
  if (!force && now - this.lastStatusRequest < 3000) {
    return
  }
  // ... 执行请求
}
```

#### 新增统一状态同步方法
```javascript
// 专门用于路由切换等场景的状态同步
syncUserStatus() {
  return new Promise((resolve) => {
    // 立即发送自己的在线状态
    this.sendUserStatus('online')
    
    // 强制请求所有用户状态
    this.requestOnlineUserStatus(true)
    
    // 触发本地状态更新事件
    window.dispatchEvent(new CustomEvent('userStatusChange', {
      detail: {
        userId: this.currentUser.id,
        status: 'online',
        immediate: true,
        source: 'sync'
      }
    }))
    
    setTimeout(() => resolve(), 500)
  })
}
```

### 2. 路由切换处理优化

#### App.vue 路由监听简化
```javascript
// 只在切换到聊天页面时进行状态同步
if (to.path.includes('/chat') && from.path !== to.path) {
  webSocketService.syncUserStatus().then(() => {
    console.log('状态同步完成')
  })
} else {
  // 其他路由只发送基本状态事件
  window.dispatchEvent(new CustomEvent('userStatusChange', {
    detail: {
      userId: user.id,
      status: 'online',
      immediate: true,
      source: 'route_change'
    }
  }))
}
```

#### Chat.vue 组件挂载优化
```javascript
// 统一进行状态同步，避免多次重复请求
if (webSocketService.isConnected()) {
  try {
    await webSocketService.syncUserStatus()
    console.log('Chat页面状态同步完成')
  } catch (error) {
    // 降级处理：单独请求状态
    setTimeout(() => {
      webSocketService.requestOnlineUserStatus(true)
    }, 1000)
  }
}
```

### 3. 状态变化处理改进

#### 增加来源标识和去重
```javascript
const handleLocalStatusChange = (event) => {
  const { userId, status, immediate, source } = event.detail
  if (immediate && userId) {
    // 检查是否需要更新（避免不必要的响应式触发）
    const currentStatus = userOnlineStatus.value[userId]
    if (currentStatus !== status) {
      userOnlineStatus.value[userId] = status
      userOnlineStatus.value = { ...userOnlineStatus.value }
      console.log(`用户${userId}状态已更新为${status} (来源: ${source})`)
    } else {
      console.log(`用户${userId}状态无变化，跳过更新`)
    }
  }
}
```

### 4. 后端状态管理增强

#### 改进状态请求处理
```java
// 确保请求者自己在在线列表中
if (message.getSenderId() != null) {
    onlineUsers.put(message.getSenderId(), "online");
}

// 记录状态变化日志
String oldStatus = onlineUsers.get(message.getSenderId());
if ("online".equals(status)) {
    onlineUsers.put(message.getSenderId(), status);
    if (!"online".equals(oldStatus)) {
        log.info("用户 {} 状态更新: {} -> {}", message.getSenderId(), oldStatus, status);
    }
}
```

#### 增强断开连接处理
```java
// 先处理状态更新（从在线列表中移除）
webSocketService.handleUserStatusUpdate(statusMessage);

// 再广播离线状态
webSocketService.broadcast(statusMessage);
```

### 5. 调试工具

添加了 WebSocket 调试工具 (`webSocketDebug.js`)，支持：
- 状态变化历史记录
- 事件日志追踪
- 调试报告生成
- 开发环境自动启用

使用方法：
```javascript
// 控制台查看调试报告
window.wsDebug.printReport()

// 清除调试日志
window.wsDebug.clearLogs()

// 手动启用/禁用调试
window.wsDebug.enable()
window.wsDebug.disable()
```

## 优化效果

1. **消除竞态条件**：统一状态同步入口，避免多个异步操作冲突
2. **提高响应速度**：路由切换时强制刷新状态，跳过防抖限制
3. **增强可靠性**：后端状态清理更及时，防止内存泄漏
4. **改善调试体验**：提供详细的状态变化日志和调试工具

## 测试建议

1. **路由切换测试**：在不同页面间快速切换，观察好友列表状态
2. **WebSocket重连测试**：断开网络后重连，验证状态恢复
3. **多用户场景测试**：多个用户同时在线，验证状态同步
4. **异常场景测试**：强制关闭浏览器，验证离线状态广播

## 注意事项

1. 调试工具仅在开发环境启用，生产环境会自动禁用
2. 状态同步有500ms的延迟以确保WebSocket消息传输完成
3. 保持了原有的心跳机制和定期状态检查
4. 兼容现有的通知和聊天功能 